var md = "\n## 1.1本人cd\n>**本博客会记录本人在玩转Pandas数据结构过程中的点点滴滴，此博文会不定时更新，信息量较大，且较繁琐，如果有涵盖不到的地方，或者有错误的地方，欢迎在下方评论中指出！**\n\n### 运行环境\n**操作系统**：`Centos 7.3`\n\n**Python **：`Python3.6.5 [GCC 4.8.5 20150623 (Red Hat 4.8.5-16)] on linux`\n\n**常用链接：**\n\n[**Python3 API 官方文档**](https://docs.python.org/3/library/index.html)\n\n[**Pandas API 官方文档**](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.html)\n\n## Pandas安装\n\n#### 在线安装\n直接执行`pip install pandas`安装即可。\n#### 离线安装\n1. 在**相同的**（主要指的是：\n1：Python版本(2、3)\n2：操作系统相同(windows、mac、linux)\n3：系统位数(32、64)\n）、**有网的**环境下 执行`pip download pandas`,下载`Pandas` Package 以及依赖Packages。\n2. 在目的系统下新建**Pandas**文件夹并进入**Pandas**文件夹，将pip下载到的文件拷贝进来，执行`pip install *`\n\n\n## Pandas 简介\n\n**Pandas**是一个Python第三方包，提供了**快速**、**灵活**和**富有表现力**的数据结构，能够**简单**、**直观**处理“关系”或“标记”类数据。它致力于成为Python中进行数据分析的基础和高级模块。此外，它还有更广泛的目标，即成为任何语言中可用的最强大、最灵活的开源数据分析/操作工具。它已经朝着这个目标前进了。\n## Pandas 数据结构\n\n**Pandas** 作为强大的数据分析Package，有自己独特的数据存储结构,根据维度可划分为：一维`Series`、二维`DataFrame`、三维`Panel`。\n本文主要涉及一维`Series` 和 二维`DataFrame`、三维`Panel`请自行研究。\n### Series\n**Series**是一个一维的类似于`list`对象的数据结构，但**Series**和`list`不同的是：\n- **Series**  有自己独特的`index`查询对象。\n- **Series**  独特的***增删改查***方式。\n- **Series**  有***批量处理***的方式，***批量处理*** 在减少了代码中`for`关键字的存在的同时也提高了性能.\n- 更多详情请参考官方文档：[**Series**](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.html)\n\n### DataFrame\n\n**DataFrame**对象是一个 `row`,`column`均可自由变换的二维数据结构，与常见关系类数据库中的表数据结构极其类似，由于**DataFrame**极其丰富的数据`API`接口，**DataFrame**对象与**Python**的完美结合基本可以实现并简化你的所有数据操作, 而这是`SQL`所远远无法达到的。\n\n**DataFrame**可以看做是**Series**的组合，对**DataFrame**对象的 `row`,`column`都可以看做是由一个**Series**对象构成的，因此对**DataFrame**选取出的 `row`或`column`的操作与**Series**操作基本相同。\n\n### Panel\nPanel是一个三维的数据结构，由于可视化效果以及理解能力较差，一般都转化为DataFrame在处理，使用次数较少，如有需要，请翻阅 [**Pandas API 官方文档**](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.html)\n\n\n## 初始化数据\n本文主要涉及 **Series** 和 **DataFrame** 的初始化方式。\n>**Series**对象的操作方式是极其类似的，因此在**Series**中支持的操作，**DataFrame**中一般也是支持的，本文中不会重复赘述。\n\n#### Series\n**Series**是一个一维的类似于`list`对象的数据结构，但**Series**和`list`不同的是\n- **Series**  有自己独特的`index`查询对象。\n- **Series**  独特的***增删改查***方式。\n- **Series**  有***批量处理***的方式，***批量处理*** 大大减少了代码中`for`关键字的存在.\n- 更多详情请参考官方文档：[**`Series`**](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.html)\n\n**Series构造函数**：\n\n`pandas.Series(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)`\n\n- `data`:  类`array`对象，dict对象，标称型对象\n\n - **类`array`对象 :** 常用的有list对象，np.array对象，如果数据都多维，只会解析最外围的一层，该类对象在初始化时，如果不主动指定index参数，index对象会有默认的RangeIndex自动创建。\n \n - **`dict`对象：**传入dict对象时，dict.key()会自动被解析为**Series**的index对象，dict.values()会被自动解析为data。\n >自Python3.6起,dict对象是有序的，pandas自0.23起支持dict对象的有序初始化。\n - **标称型对象 :** 用的比较少，请自行研究。\n\n- `index`: array对象，pd.Index对象。\n\n- 其他参数不常用，如有需要请自行研究。\n\n#### DataFrame\n**DataFrame** 对象是一个 `row column`均可自由变换的二维数据结构，与常见关系类数据库中的表数据结构极其类似，由于 **DataFrame** 极其丰富的数据`API`接口，  **DataFrame** 对象与 **Python** 的完美结合可以大幅简化你的数据操作, 其中很多操作都是`SQL`所远远无法实现的。\n **DataFrame** 对象的每一列,每一行都是由一个 **Series** 对象构成的。因此对 **DataFrame** 选取出的行/列的操作与 **Series** 操作基本相同。\n \n**DataFrame构造函数**：\n\n`pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False)`\n\n- `columns`: 类似于index参数，只不过指定是的列索引。\n- 其他参数与属性与 **Series** 基本类似。\n\n>Pandas全文数据对象定义，为降低篇幅，你可以认为，其他地方出现的代码之前都默认引用了该段代码：\n```python\n'''导入numpy, pandas Packages'''\n>>> import pandas as pd\n>>> np = pd.np\n'''Series一维数据结构初始化'''\n>>> sr = pd.Series([1,2,3])\n>>> sr\n0    1\n1    2\n2    3\ndtype: int64\n'''DataFrame二维数据结构初始化'''\n>>> df = pd.DataFrame([[1,2,3]],columns=['a','b','c'])\n>>> df\n   a  b  c\n0  1  2  3\n```\n\n## 索引\n\n>Series和DataFrame对象的大部分操作都是通过索引完成的，因此对`index` 和 `columns`索引对象的研究极其重要!!!\n\n索引常用的有 `int` 和 `str`类型，不常用的有 `DatetimeIndex`, `CategoricalIndex`, `IntervalIndex`, 如有需求，请翻官方文档。\n#### Series\n```python\n'''由于初始化时未选择，由pd.RangIndex自动创建，start=0,stop=3,step=1 即指的是[0,1,2]'''\n>>> sr.index\nRangeIndex(start=0, stop=3, step=1)\n```\n#### DataFrame\n```python\n'''查看df的行索引：由于初始化时未选择，由pd.RangIndex自动创建，start=0,stop=3,step=1 即指的是[0,1,2]'''\n>>> df.index\nRangeIndex(start=0, stop=1, step=1)\n\n'''查看df的列索引：df的列索引是主动创建的 即指的是['a', 'b', 'c']'''\n>>> df.columns\nIndex(['a', 'b', 'c'], dtype='object')\n```\n\n\n## 选取数据（也称过滤数据）\n[**参考博客(csdn)： pandas中Dataframe的查询方法（[], loc, iloc, at, iat, ix）**](https://blog.csdn.net/wr339988/article/details/65446138)\n\n#### Series\n - **绝对索引**： 选取到的是具体存储的值(索引不存在时会抛出`KeyError`)\n - **切片索引**： 选取到的是命中切片的**Series**对象\n - **条件索引**： 选取到的是命中条件的**Series**对象\n\n```python\n>>> sr[0]\n1\n>>> sr.loc[0]\n1\n>>> sr[100]\n'''异常较长，再次简化了'''\nKeyError: 100\n```\n\n\n\n#### DataFrame\n - **绝对索引**： 选取到的是对应的**Series**对象(索引不存在时会抛出`KeyError`)\n   - **行索引**：选取到的**Series**对象的数据为选取到的**行**的数据，对应的索引变为**列**索引\n   - **列索引**：选取到的**Series**对象的数据为选取到的**列**的数据，对应的索引变为**行**索引\n - **切片索引**： 选取到的是命中切片的**DataFrame**对象\n - **条件索引**： 选取到的是命中条件的**DataFrame**对象\n\n\n\n**具体的选取函数**：\n - `切片[]`：类似于`list`, 可执行`行选取`和`列选取`，选取规则：`左闭，右开`。\n```python\n>>> sr[0]\n1\n>>> sr[0:1]\n0    1\n>>> df['a']\n0    1\nName: a, dtype: int64\n```\n\n - `loc[]`：类似于`切片[]`，不过与`切片[]`不同的是，选取规则：`左闭，右闭`。\n```python\n>>> sr.loc[0]\n1\n>>> sr.loc[0:1]\n0    1\n1    2\ndtype: int64\n>>> df.loc[0]['a']\n1\n'''DataFrame和Series不同的是DataFrame在执行切片是返回的是DataFrame对象，在执行['a']返回的是Series对象，此时的索引变为行索引'''\n>>> df.loc[0:1]['a']\n0    1\nName: a, dtype: int64\n'''DataFrame和Series不同的是DataFrame在执行切片是返回的是DataFrame对象，在执行loc['a']返回的是Series对象，此时的索引变为列索引'''\n>>> df.loc[0:1].loc[0]\na    1\nb    2\nc    3\nName: 0, dtype: int64\n```\n\n- `iloc[]`：`loc`按索引值选取，`iloc`按照位置选取，因此`iloc`参数类型是`int`。\n```python\n>>> sr.iloc[1]\n2\n>>> sr.loc[1]\n2\n>>> sr.iloc[1:2]\n1    2\ndtype: int64\n'''修改索引'''\n>>> sr.index = [3,2,1]\n>>> sr\n3    1\n2    2\n1    3\ndtype: int64\n'''iloc访问到的值是依然是2'''\n>>> sr.iloc[1]\n2\n'''loc访问到的值是3'''\n>>> sr.loc[1]\n3\n'''DataFrame类似，不再赘述'''\n```\n- `at[]`： 与`loc`类似，但是比`loc`有更快的访问数据的速度，而且只能访问单个元素，不能访问多个元素。\n```python\n>>> sr.at[1]\n2\n'''赋值错误！'''\n>>> sr.at[1:2]\nTraceback (most recent call last):\nValueError: At based indexing on an integer index can only have integer indexers\n```\n\n- `iat[]`：与 `at`类似，`iat`按照位置选取。\n\n- `ix[]`: 主要用于DataFrame中，DataFrame采用`切片[]`默认选取的是列, 采用`df.ix[]`选取行，好像还有其他用途，暂时没用到。\n```python\n>>> df['a']\n0    1\nName: a, dtype: int64\n>>> df.ix[0]\na    1\nb    2\nc    3\nName: 0, dtype: int64\n```\n\n*注：强烈建议使用loc而尽量少使用[]，因为loc在对DataFrame进行重新赋值操作时会避免chained indexing问题，使用[]时编译器很可能会给出SettingWithCopy的警告。具体可以参见*[**`官方文档`**](http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy)\n## 遍历数据\n不多赘述，以`for`代码来进行示例，**Series**对象`sr`,**DataFrame**对象`df`。\n\n#### Series\n - 遍历索引`index` : ```for i in  sr.index```\n - 遍历值`value`: `for i in sr` 或 `for i in sr.values`\n\n#### DataFrame\n  - 遍历行索引`index` : ```for i in  df.index```\n  - 遍历列索引`columns` : ```for i in df``` 或 ```for i in df.columns```\n  - 遍历每一行`row` : `[df.loc[i] for i in df.index]` 或 `[df.ix[i] for i in df.index]`(列表生成式)\n  - 遍历每一列`columns` : `[df[i] for i in df]` 或 `[df[i] for i in  df.columns]`(列表生成式)\n  - 重复元素分组遍历`row` : `[df[i] for i in df.groupby(by='columnsname')]`(列表生成式)\n  \n>可能不全，但其他**大部分**组合的数据遍历均可由 **选取数据** 和 **遍历数据** 灵活组成！\n  \n## 插入数据\n#### Series\n  - **赋值式插入** :\n  `sr[index] = value` 或 `sr.loc[index] = value`，准确来说，这个叫做赋值操作，如果index已经存在如果index已经存在的话会覆盖原来index索引的值，因此使用时确认是**插值操作**一定要注意不要覆盖原来的值，保险起见可以先判断一下索引是否存在`if index in sr.index`.\n  **循环插值Demo代码**:\n```python\n>>> sr = pd.Series()\n>>> sr\nSeries([], dtype: float64)\n>>> for i in range(100):\n...     sr.loc[sr.shape] = i\n```\n\n  -  **新插入数据** :\n   1. 先插入索引`sr.reindex(sr.index.insert(item,index))`,在第`item`行前新加入一个名为`index`的索引.\n\n   2. 根据索引插入数据，同**赋值式插入**，`sr[index] = value` 或 `sr.loc[index] = value`\n  **Demo代码**:\n```python\n>>> sr = pd.Series()\n>>> sr\nSeries([], dtype: float64)\n>>> for i in range(100):\n...     sr.loc[sr.shape] = i\n>>> sr.reindex(sr.index.insert(100,100))\n>>> sr.loc[100] = 100\n```\n\n#### DataFrame\n\n插入原理与**Series**基本类似。\n  - **插入行数据** : **Demo**:\n```python\n>>> df = pd.DataFrame(columns=list('abc'))\n>>> df\nEmpty DataFrame\nColumns: [a, b, c]\nIndex: []\n'''循环逐行插入'''\n>>> for i in range(3):\n...     df.loc[df.shape[0]] = i,i,i\n>>> df\n   a  b  c\n0  0  0  0\n1  1  1  1\n2  2  2  2\n'''先指定需要插入行索引，在执行赋值操作'''\n>>> df.reindex(df.index.insert(3,3))\n>>> df.loc[3] = 3,3,3\n>>> df \n     a    b    c\n0    0    0    0\n1    1    1    1\n2    2    2    2\n3    3    3    3\n```\n\n  - **插入列数据** : **Demo**:\n```python\n>>> df = pd.DataFrame(columns=list('abc'))\n>>> df\nEmpty DataFrame\nColumns: [a, b, c]\nIndex: []\n'''直接进行赋值操作，=号右侧需为一个变量或者长度等于行长度的类list对象，否则会报错'''\n>>> df['d'] = None\n>>> df\nEmpty DataFrame\nColumns: [a, b, c, d]\nIndex: []\n'''先指定需要插入列索引，在执行赋值操作，需要注意的是reindex函数默认的行index,在初始化columns时必须显式指定'''\n>>> df = df.reindex(columns = df.columns.insert(2,'e'))\n>>> df\nEmpty DataFrame\nColumns: [a, b, e, c, d]\nIndex: []\n```\n\n### 合并数据\n\n### 删\n### 改\n批量添加数据：sr.add(100),\n### 查\n### 查\n\n\n        ";

export  default  md;